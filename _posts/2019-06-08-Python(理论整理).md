---
layout:     post
title:      Python理论
subtitle:   自己整理的一些理论
date:       2019-06-08
author:     Mr.C
header-img: img/cloud.jpg
catalog: true
tags:
    - Python
---

> 这我整理的Python理论


# 一、GIL与互斥锁
![GIL](http://m.qpic.cn/psb?/V13ZfZ4l46I0Ky/yWzUzUpQa*9rv5SJa5p9mY1y5dLEBT5mFHVLJwkZ4e8!/b/dL4AAAAAAAAA&bo=wgPqAgAAAAADBws!&rf=viewer_4)
#### **GIL介绍**：
又称全局解释器锁，每一个进程中只有一个GIL锁，GIL并不是Python语言的特性，它是在实现Python解释器时引用的一个概念。GIL只在CPython解释器上存在，作用是保证同一时间内只有一个线程在执行。

- **GIL对程序的影响：**
1. Python中同一时刻有且只有一个线程会执行；
2. Python中的多个线程由于GIL锁的存在无法利用多核CPU；
3. Python中的多线程不适合计算密集型的程序；


- **改善GIL产生的问题：**

因为GIL锁是解释器层面的锁，无法去除GIL锁在程序时带来的问题，只能去改善。
1. 更换更高版本的解释器，比如3.6，从3.2版本开始，据说Python对解释做了优化
2. 更换解释器，比如JPython，但是由于比较小众，支持的模块较少，导致开发的效率降低
3. Python为了解决程序使用多核的问题，需要大量的计算，利用多核CPU资源，使用多进程代替多线程
![互斥锁](http://m.qpic.cn/psb?/V13ZfZ4l46I0Ky/23i1J1R6uNJxNQaExgDC5pM8IMZsgwdvTHkFxS.HdrU!/b/dFQBAAAAAAAA&bo=kASQAgAAAAADByQ!&rf=viewer_4)
#### **互斥锁介绍：**
由于并发状态下，操作系统对多个进程进行调度，而多个进程可能都有操作硬件的需求，这时就会产生多个进程对资源的共享，而共享意味着竞争，会产生许多问题。这样就需要一种机制或者手段去解决竞争，使竞争变得有序化，从而使共享资源按照预定的结果去获取。这种手段就是加互斥锁。
~~~python
from multiprocessing import Lock
~~~
- **锁的好处：**

确保了某段关键代码只能由一个线程从头到尾完整地执行
- **锁的坏处：**

阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了
- **死锁的概念：**

由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁

---

# 二、TCP的三次握手四次挥手
![三次握手](http://m.qpic.cn/psb?/V13ZfZ4l46I0Ky/qc5erDt3yj13XamzjbkMFT9ulamrSxyrlW.H6.Banno!/b/dL8AAAAAAAAA&bo=cQRAAgAAAAADJzU!&rf=viewer_4)
#### **三次握手的步骤**

（1）第⼀次握⼿：Client将标志位SYN置为1，随机产⽣⼀个值seq=J，并将该数据包发送给Server，
Client进⼊SYN_SENT状态，等待Server确认。

（2）第⼆次握⼿：Server收到数据包后由标志位SYN=1知道Client请求建⽴连接，Server将标志位
SYN和ACK都置为1，ack=J+1，随机产⽣⼀个值seq=K，并将该数据包发送给Client以确认连接请
求，Server进⼊SYN_RCVD状态。

（3）第三次握⼿：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK
置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确
则连接建⽴成功，Client和Server进⼊ESTABLISHED状态，完成三次握⼿，随后Client与Server之间
可以开始传输数据了。

- **为什么需要三次握⼿，两次不可以吗？或者四次、五次可以吗？**

我们来分析⼀种特殊情况，假设客户端请求建⽴连接，发给服务器SYN包等待服务器确认，
服务器收到确认后，如果是两次握⼿，假设服务器给客户端在第⼆次握⼿时发送数据，数据从服
务器发出，服务器认为连接已经建⽴，但在发送数据的过程中数据丢失，客户端认为连接没有建
⽴，会进⾏重传。假设每次发送的数据⼀直在丢失，客户端⼀直SYN，服务器就会产⽣多个⽆效
连接，占⽤资源，这个时候服务器可能会挂掉。这个现象就是我们听过的“SYN的洪⽔攻击”。
- **总结**

第三次握⼿是为了防⽌：如果客户端迟迟没有收到服务器返回确认报⽂，这时会放弃
连接，重新启动⼀条连接请求，但问题是：服务器不知道客户端没有收到，所以他会收到两个连
接，浪费连接开销。如果每次都是这样，就会浪费多个连接开销

![四次挥手](http://m.qpic.cn/psb?/V13ZfZ4l46I0Ky/cnf6jAN8UmBz.ZVTzJKTkpb9Q2bCJK5p5aB9xiXH.8w!/b/dMUAAAAAAAAA&bo=zQRAAwAAAAADR.g!&rf=viewer_4)
#### **四次挥手的步骤**

(1)第⼀次挥⼿：主机1（可以是客户端，也可以是服务器端），设置 Sequence
Number 和 Acknowledgment Number ，向主机2发送⼀个 FIN 报⽂段；此时，主机1进
⼊ FIN_WAIT_1 状态；这表示主机1没有数据要发送给主机2了；

(2)第⼆次挥⼿：主机2收到了主机1发送的 FIN 报⽂段，向主机1回⼀个 ACK 报⽂段， Acknowledgment
Number 为 Sequence Number 加1；主机1进⼊ FIN_WAIT_2 状态；主机2告诉主机1，我也没有数据要
发送了，可以进⾏关闭连接了；

(3)第三次挥⼿：主机2向主机1发送 FIN 报⽂段，请求关闭连接，同时主机2进⼊ CLOSE_WAIT 状态；

(4)第四次挥⼿：主机1收到主机2发送的 FIN 报⽂段，向主机2发送 ACK 报⽂段，然后主机1进
⼊ TIME_WAIT 状态；主机2收到主机1的 ACK 报⽂段以后，就关闭连接；此时，主机1等待2MSL后依
然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

- **为什么连接的时候是三次握⼿，关闭的时候却是四次握⼿？**

因为当Server端收到Client端的SYN连接请求报⽂后，可以直接发送SYN+ACK报⽂。其中
ACK报⽂是⽤来应答的，SYN报⽂是⽤来同步的。但是关闭连接时，当Server端收到FIN报⽂
时，很可能并不会⽴即关闭SOCKET，所以只能先回复⼀个ACK报⽂，告诉Client端，“你发的
FIN报⽂我收到了”。只有等到我Server端所有的报⽂都发送完了，我才能发送FIN报⽂，因此不

能⼀起发送。故需要四步握⼿

---

# 三、IO密集型与计算密集型
#### **IO密集型**

IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。

#### **计算密集型**

计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。

---

# 四、长连接与短连接
#### **长连接**

连接->传输数据->保持连接 -> 传输数据-> ………..->直到一方关闭连接，多是客户端关闭连接。 长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。HTTP在短链接和长连接上的选择：HTTP是无状态的 ，也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话
HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了持久连接支持(貌似最新的HTTP1.1 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。
如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了带宽。
实现长连接要客户端和服务端都支持长连接。

- **tcp长连接优缺点：**

长连接可以省去较多的tcp建立/关闭的操作，减少浪费，节省时间，对于频繁请求资源的客户，较适用于长连接；client和server如果长时间不关闭的话，会存在一个问题，随着客户的越来越多，server早晚会有扛不住的一天，这时需要采取一些策略，如关闭一些长时间不读写操作的连接，这样可以避免一些恶意连接导致server端服务受损，如果条件再允许，就可以以客户端为颗粒度，限制每个客户端的最大连接数

#### 短连接
连接->传输数据->关闭连接
比如HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。
具体就是 浏览器client发起并建立TCP连接 -> client发送HttpRequest报文 -> server接收到报文->server handle并发送HttpResponse报文给前端,发送完毕之后立即调用socket.close方法->client接收response报文->client最终会收到server端断开TCP连接的信号->client 端断开TCP连接，具体就是调用close方法。
也可以这样说：短连接是指SOCKET连接后，发送接收完数据后马上断开连接。 因为连接后接收了数据就断开了，所以每次数据接受处理不会有联系。 这也是HTTP协议无状态的原因之一。

- **tcp短连接优缺点：**

短连接对于服务器来说较为简单，存在的连接都是有用的连接，不需要额外的控制，但如果客户端连接频繁，会在tcp的建立和关闭上浪费时间。

---

# 五、乐观锁与悲观锁

#### 悲观锁

- **介绍**

悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

~~~mysql
"""例子 ps:有点像mysql事务"""
select num from table where id=1 for update;
~~~



#### 乐观锁

- **介绍**

乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

~~~mysql
"""例子"""
updata table set num=1 where id=1 and num=2;
~~~



**二者评价**

两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。



---

# 六、类方法&类实例方法&静态方法

- **类方法**

是类对象的方法，在定义时需要在上方使用"@classmethod",进行装饰，形参为cls,表示类对象，类对象和实例对象都可调用

- **类实例方法**

是类实例化的方法，只有实例对象可以调用，形参为self，指代对象本身

- **静态方法**

是一个任意函数，在其上方使用"@staticmethod"进行装饰，可以用对象直接调用，静态方法实际上跟该类没有太大关系



---

# 七、闭包与装饰器

#### 闭包

闭包(closure)在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为
闭包

- 必须有一个内嵌函数
- 内嵌函数必须引用外部函数中的变量
- 外部函数的返回值必须是内嵌函数

#### 装饰器

装饰器(decorator)就是一种闭包的引用，只不过其传递的是函数

~~~python
from functools import wraps
~~~



---

# 八、生成器与迭代器

#### 迭代器

迭代器是一个更抽象的概念，任何对象，如果它的类有 next 方法和iter 方法返回自己本身，在没有后续元素时，next()会抛出一个StopIteration异常

#### 生成器

生成器（Generator）是创建迭代器的简单而强大的工具。它们写起来就像是正规的函数，只是在需要返回数据的时候使用 yield 语句



- **区别**

生成器能做到迭代器能做的所有事，而且因为自动生成iter()和next()方法，生成器显得特别简洁，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存，除了创建和保存程序状态的自动方法，当发生器终结时，还会抛出StopIteraion异常



---



# 九、可变对象和不可变对象

**不可变对象**，该对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，相当
于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。

**可变对象**，该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接
发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。



---



# 十、进程&线程&协程

#### 进程

- 进程是CPU系统进行资源分配和调度的独立单位
- 进程效率低的原因
  - 进程之间不共享任何状态，进程的调度由操作系统完成，每个进程都有自己的独立的内存空间
  - 进程间的通讯主要是通过信号传递的方式来实现的，实现的方式有多种，信号量，管道，事件等，任何一种方式的通讯效率都需要通过内核，导致通讯效率比较低。
  - 由于是独立的内存空间，上下文切换的时候需要保存先调用栈的信息，CPU各寄存器的信息，虚拟内存，以及打开的相关句柄等信息，所以导致上下文进程间切换开销很大，通讯麻烦。
- 



# 十一、同步&异步&回调

**同步：**多个任务之间有先后顺序执行，一个执行完下个才能执行。
**异步：**多个任务之间没有先后顺序，可以同时执行有时候一个任务可能要在必要的时候获取另一个
同时执行的任务的结果，这个就叫回调！
**阻塞：**如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。
**非阻塞：**如果不会卡住，可以继续执行，就是说非阻塞的。
同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。



---



# 十二、CSRF和CORS

#### CSRF

（Cross-Site Request Forgery，跨站点伪造请求）是一种网络攻击方式，该攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在未授权的情况下执行在权限保护之下的操作，具有很大的危害性。具体来讲，可以这样理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

#### CORS

提起浏览器的同源策略，大家都很熟悉。不同域的客户端脚本不能读写对方的资源。但是实践中有一些场景需要跨域的读写，所以出现了一些hack的方式来跨域。比如在同域内做一个代理，JSON-P等。但这些方式都存在缺陷，无法完美的实现跨域读写。所以在XMLHttpRequest v2标准下，提出了CORS(Cross Origin Resourse-Sharing)的模型，试图提供安全方便的跨域读写资源。目前主流浏览器均支持CORS。

---



# 十三、负载均衡

对于负载均衡，最重要的就是所有服务器的数据都是实时同步的。这是一个集群所必需的，因
为，如果数不据实时、不同步，那么用户从一台服务器读出的数据，就有别于从另一台服务器读出
的数据，这是不能允许的。所以必须实现数据库的数据同步。这样，在查询的时候就可以有多个资
源，实现均衡。



---



# 十四、WSIG、uWSIG、uwsig、Nginx

要注意 **WSGI / uwsgi / uWSGI** 这三个概念的区分。

- WSGI是一种通信协议。
- uwsgi是一种线路协议而不是通信协议，在此常用于在uWSGI服务器与其他网络服务器的数据通信。
- 而uWSGI是实现了uwsgi和WSGI两种协议的Web服务器。

uwsgi协议是一个uWSGI服务器自有的协议，它用于定义传输信息的类型（type of information），每一个uwsgi packet前4byte为传输信息类型描述，它与WSGI相比是两样东西。

#### WSGI
WSGI的全称是Web Server Gateway Interface（Web服务器网关接口），它不是服务器、python模块、框架、API或者任何软件，只是一种描述web服务器（如nginx，uWSGI等服务器）如何与web应用程序（如用Django、Flask框架写的程序）通信的规范。

server和application的规范在PEP3333中有具体描述，要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Bottle, Flask, Django。

#### uWSGI
uWSGI是实现了uwsgi和WSGI两种协议的Web服务器。uWSGI是一个全功能的HTTP服务器，实现了WSGI协议、uwsgi协议、http协议等。它要做的就是把HTTP协议转化成语言支持的网络协议。比如把HTTP协议转化成WSGI协议，让Python可以直接使用。

#### uwsgi

uwsgi协议是一个uWSGI服务器自有的协议，与WSGI一样，是uWSGI服务器的独占通信协议，用于定义传输信息的类型(type of information)。每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是fcgi协议的10倍快。

#### Nginx

Nginx是一个Web服务器其中的HTTP服务器功能和uWSGI功能很类似，但是Nginx还可以用作更多用途，比如最常用的反向代理功能。Nginx(发音同 engine x)是一款基于异步框架的轻量级/高性能的Web 服务器/反向代理服务器/缓存服务器/电子邮件(IMAP/POP3)代理服务器，并在一个BSD-like 协议下发行。
