---
layout:     post
title:      Mysql(一)
subtitle:   Mysql 理论
date:       2019-06-16
author:     Mr.C
header-img: img/mysql.jpg
catalog: true
tags:
    - Mysql
    - Database

---

> 一般情况下，可以将数据库分为**关系型数据库**和**非关系型数据库**。
>> 关系数据库，是指采用了关系模型来组织数据的数据库，关系模型指的就是二维表格模型，关系型数据库就是由二维表及其之间关系的联系所组成的一个数组组织。 <br> 
非关系型数据库，又被称为NoSQL（Not Only SQL )，意为不仅仅是SQL，对NoSQL 最普遍的定义是“非关联型的”，强调Key-Value 的方式存储。
>>> 数据库管理系统（英语：Database Management System，简称DBMS）是为管理数据库而设计的软件系统，包括三大部分构成: <br> 
1.数据库文件集合. 主要是一系列的数据文件, 作用是存储数据。 <br> 
2.数据库服务端. 主要负责对数据文件以及文件中的数据进行管理。 <br> 
3.数据库客户端. 主要负责和服务端通信, 向服务端传输数据或者从服务端获取数据。 <br> 

## Mysql 理论

> 刚开始时，我还是一个只会用 `select * from ...` 的小菜鸟，后来有缘找到一份阿里云关系数据库的资料 林晓斌 前辈的Mysql讲解专访，博客中我会引用一些该前辈的话、资料图片及自己的理解。

#### Mysql体系结构
![Mysql](http://www.c-blogs.cn/img/Mysql.png)


> **连接器(connector)**

连接器，顾名思义，它的作用就是负责跟客户端建立连接、获取权限、维持和管理连接。
~~~python
"""mysql 连接命令"""
mysql -h$ip -P$port -u$user -p$password
~~~
连接命令是客户端工具，建立完成TCP的三次握手后，就会开始认证用户身份，user、password，如果验证失败就会报 `Access denied for user` 的错误，如果验证通过连接器会查询该用户拥有的权限。


![connections](http://www.c-blogs.cn/img/mysql-connections.png)
~~~mysql
show variables like '%connections%';
~~~
    extra_max_connections：额外最大连接数
    max_connections：MySQL的最大连接数限制
    max_user_connections：是单个用户的最大连接数，这里未指明是哪个用户，是任意一个用户

> **查询缓存(Cache、Buffer)**

连接建立好后，就可以执行 `select` 语句了，执行逻辑就会来到第二步：查询缓存。如果能从缓存中找到key，那么这个value就会被直接返回给客户端。如果语句不存在，就会执行并语句，执行结果会存入查询缓存中并把结果返回。

![CahceBuffer](http://www.c-blogs.cn/img/mysql-cache.png)
    全局和引擎特定的缓存和缓冲区
    
> **分析器(Parser)**

当语句没有命中查询缓存，就要开始真正执行语句了。分析器先会做"词法分析"，例子：`select * from mysql.user \G` ，解析字符串分别是什么，代表什么。做完识别后，就要做"语法分析"，就会根据语法规则，判断是否满足MySQL语法。如果不对，就会报 `You have an error in your SQL syntax` 的错误。

> **优化器(Optimizer)**

经过了分析器后，Mysql就知道你要做什么，在返回数据之前，还要经过优化器的处理。通过 `optimizer_switch` 控制优化行为。

> **执行器**

经过种种'考验'后，终于进入执行器阶段，但在执行的时候，要判断该用户是否对查询的表、查询的字段等是否有权限，查询也会在优化器之前调用precheck验证权限。如果有，执行器就会根据表的引擎定义，去使用引擎提供的接口，至此，这个语句就执行完成了。

> **引擎(engine)**

![engine](http://www.c-blogs.cn/img/mysql-engine.png)

![engine](http://www.c-blogs.cn/img/mysql-engines.png)
· MyISAM：默认的MySQL插件式存储引擎，它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。注意，通过更改STORAGE_ENGINE配置变量，能够方便地更改MySQL服务器的默认存储引擎。

· InnoDB：用于事务处理应用程序，具有众多特性，包括ACID事务支持。(提供行级锁)

· BDB：可替代InnoDB的事务引擎，支持COMMIT、ROLLBACK和其他事务特性。

· Memory：将所有数据保存在RAM中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。

· Merge：允许MySQL DBA或开发人员将一系列等同的MyISAM表以逻辑方式组合在一起，并作为1个对象引用它们。对于诸如数据仓储等VLDB环境十分适合。

· Archive：为大量很少引用的历史、归档、或安全审计信息的存储和检索提供了完美的解决方案。

· Federated：能够将多个分离的MySQL服务器链接起来，从多个物理服务器创建一个逻辑数据库。十分适合于分布式环境或数据集市环境。

· Cluster/NDB：MySQL的簇式数据库引擎，尤其适合于具有高性能查找要求的应用程序，这类查找需求还要求具有最高的正常工作时间和可用性。

· Other：其他存储引擎包括CSV（引用由逗号隔开的用作数据库表的文件），Blackhole（用于临时禁止对数据库的应用程序输入），以及Example引擎（可为快速创建定制的插件式存储引擎提供帮助）。

## 数据设计

#### ER模型

> 在做项目中，需求分析是极为重要的一个环节，而作为整个项目的核心 `数据` 更是重中之重。

![ER](http://www.c-blogs.cn/img/ER.png)

**E-R**模型(Entity-Relationship),也有人称为E-R方法。它提供不受任何**DBMS**(database manage system)约束的面向用户的表达方式，是数据建模工具，是表示概念模型的一种方式。

> 联系可分为3种类型：

- **一对一关系**

例如：一个公司有一个项目经理，而那些项目经理只在一个公司任职，则公司与项目经理的关系是一对一。

- **一对多关系**

例如：教师与课程之间存在一对多的联系“教”，即每位教师可以教多门课程，但是每门课程只能由一位教师来教。

- **多对多关系**

例如：学生与课程间的联系(“学”)是多对多的，即一个学生可以学多门课程，而每门课程可以有多个学生来学。

#### 范式与反范式

> 范式(Normal Form)：范式是关系数据库理论的基础，也是我们再设计数据库结构过程中所要遵循的规则和指导方法，共有8种范式，依次是：1NF，2NF，3NF，BCNF，4NF，5NF，DKNF，6NF。通常所用到的只是三个范式，即：第一范式（1NF），第二范式（2NF），第三范式（3NF）。

- 第一范式(1NF)

强调的是列的**原子性**，即列不能够再分成其他的列。

|学号|姓名|手机号|
|----|----|------|
|1|廖|18888888888|

- 第二范式(2NF)

再第一范式的基础上，实体属性完全依赖于主键

|学号|姓名|课程号|授课老师|
|----|----|------|--------|
|1|廖|1|某老师|

可分解为两个表，达到完全依赖

|学号|姓名|
|----|----|
|1|廖|

|学号|课程号|授课老师|
|----|------|--------|
|1|1|某老师|

- 第三范式(3NF)

在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）

|学号|系名|系主任|
|----|----|------|
|1|计算机|某主任|

~~~python
学号 --> 系名 --> 系主任
学号 --> 系主任
ps:为传递依赖
~~~

同样可以分解为两张表：

|学号|系名|
|----|----|
|1|计算机|

|系名|系主任|
|----|------|
|计算机|某主任|

- 反范式

没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，减少了查询时的关联，提高查询效率，因为在数据库的操作中查询的比例要远远大于DML的比例。但是反范式化一定要适度，并且在原本已满足三范式的基础上再做调整的。

## 数据库优化

> - 在进行表设计时，可适度增加冗余字段(反范式设计)，减少JOIN操作； <br> 
> - 多字段表可以进行垂直分表优化，多数据表可以进行水平分表优化； <br> 
> - 选择恰当的数据类型，如整型的选择； <br> 
> - 对于强调快速读取的操作，可以考虑使用MyISAM数据库引擎； <br> 
> - 对较频繁的作为查询条件的字段创建索引；唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件；更新非常频繁的字段不适合创建索引； <br> 
> - 编写SQL时使用上面的方式对SQL语句进行优化； <br> 
> - 使用慢查询工具找出效率低下的SQL语句进行优化； <br> 
> - 构建缓存，减少数据库磁盘操作； <br> 
> - 可以考虑结合使用内在型数据库，如Redis，进行混合存储。

#### SQL查询优化

- SQL语句
    - 1.避免全表扫描，应考虑在 where 及 order by 涉及的列上建立索引
    - 2.查询时使用select明确指明所要查询的字段，避免使用select *的操作
    - 3.SQL语句尽量大写，如：
    
    ~~~
    SELECT name FROM t WHERE id=1
    ~~~
    
    - 4.尽量避免在 where 子句中使用!=或<>操作符， MySQL只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE
    
    ~~~
    SELECT id FROM t WHERE name LIKE ‘abc%’
    ~~~
    
    - 5.遵循最左原则，在where子句中写查询条件时把索引字段放在前面
    
    ~~~
    mobile为索引字段，name为非索引字段
    推荐
    SELECT ... FROM t WHERE mobile='13911111111' AND name='python'
    不推荐
    SELECT ... FROM t WHERE name='python' AND mobile='13911111111' 
    
    建立了复合索引 key(a, b, c)
    推荐
    SELECT ... FROM t WHERE a=... AND b=... AND c= ...
    SELECT ... FROM t WHERE a=... AND b=...
    SELECT ... FROM t WHERE a=...
    不推荐 (字段出现顺序不符合索引建立的顺序)
    SELECT ... FROM t WHERE b=... AND c=...
    SELECT ... FROM t WHERE b=... AND a=... AND c=...
    ...
    ~~~
    
    - 6.能使用关联查询解决的尽量不要使用子查询
    
    ~~~
    子查询
    SELECT article_id, title FROM t_article WHERE user_id IN (SELECT user_id FROM t_user  WHERE user_name IN ('itcast', 'itheima', 'python'))
    
    关联查询(推荐)
    SELECT b.article_id, b.title From t_user AS a INNER JOIN t_article AS b ON a.user_id=b.user_id WHERE a.user_name IN ('itcast', 'itheima', 'python');
    ~~~
    
    - 7.不需要获取全表数据的时候，不要查询全表数据，使用LIMIT来限制数据

#### 分表分库

任何问题都是太大或者太小的问题，我们这里面对的数据量太大的问题。

- 用户请求量太大

    因为单服务器TPS，内存，IO都是有限的。 解决方法：分散请求到多个服务器上； 其实用户请求和执行一个sql查询是本质是一样的，都是请求一个资源，只是用户请求还会经过网关，路由，http服务器等。

- 单库太大

    单个数据库处理能力有限；单库所在服务器上磁盘空间不足；单库上操作的IO瓶颈 解决方法：切分成更多更小的库

- 单表太大

    CRUD都成问题；索引膨胀，查询超时 解决方法：切分成多个数据集更小的表。

*分库分表的方式方法*

- 垂直拆分

    也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。

- 垂直分库

    垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。 切分后，要放在多个服务器上，而不是一个服务器上。为什么？ 我们想象一下，一个购物网站对外提供服务，会有用户，商品，订单等的CRUD。没拆分之前， 全部都是落到单一的库上的，这会让数据库的单库处理能力成为瓶颈。按垂直分库后，如果还是放在一个数据库服务器上， 随着用户量增大，这会让单个数据库的处理能力成为瓶颈，还有单个服务器的磁盘空间，内存，tps等非常吃紧。 所以我们要拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。

    数据库业务层面的拆分，和服务的“治理”，“降级”机制类似，也能对不同业务的数据分别的进行管理，维护，监控，扩展等。 数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。 数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈。
    
- 水平拆分

    - 水平分表
    
        针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。

    - 水平分库分表
        
        将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。
        
    - 水平分库分表切分规则
    
    - > 范围拆分(RANGE)： <br> 
        从0到10000一个表，10001到20000一个表； <br> 
         <br> 
        HASH取模 离散化： <br> 
        一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。 <br> 
         <br> 
        地理区域： <br> 
        比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。 <br> 
         <br> 
        时间： <br> 
        按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。
    
#### 分库分表后面临的问题
- 事务支持

    分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。

- 多库结果集合并（group by，order by）

- 跨库join

    分库分表后表之间的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表， 结果原本一次查询能够完成的业务，可能需要多次查询才能完成。 粗略的解决方法： 全局表：基础数据，所有库都拷贝一份。 字段冗余：这样有些字段就不用join去查询了。 系统层组装：分别查询出所有，然后组装起来，较复杂。
        
    


**注：原创文章，转载请注明出处**
