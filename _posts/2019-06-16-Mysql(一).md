---
layout:     post
title:      Mysql(一)
subtitle:   Mysql 理论
date:       2019-06-16
author:     Mr.C
header-img: img/mysql.jpg
catalog: true
tags:
    - Mysql
    - Database

---

> 一般情况下，可以将数据库分为**关系型数据库**和**非关系型数据库**。
>> 关系数据库，是指采用了关系模型来组织数据的数据库，关系模型指的就是二维表格模型，关系型数据库就是由二维表及其之间关系的联系所组成的一个数组组织。 <br> 
非关系型数据库，又被称为NoSQL（Not Only SQL )，意为不仅仅是SQL，对NoSQL 最普遍的定义是“非关联型的”，强调Key-Value 的方式存储。
>>> 数据库管理系统（英语：Database Management System，简称DBMS）是为管理数据库而设计的软件系统，包括三大部分构成: <br> 
1.数据库文件集合. 主要是一系列的数据文件, 作用是存储数据。 <br> 
2.数据库服务端. 主要负责对数据文件以及文件中的数据进行管理。 <br> 
3.数据库客户端. 主要负责和服务端通信, 向服务端传输数据或者从服务端获取数据。 <br> 

## Mysql 理论

> 刚开始时，我还是一个只会用`select * from ...`的小菜鸟，后来有缘找到一份阿里云关系数据库的资料 林晓斌 前辈的Mysql讲解专访，博客中我会引用一些该前辈的话、资料图片及自己的理解。

#### Mysql体系结构
![Mysql](http://www.c-blogs.cn/img/Mysql.png)


> **连接器(connector)**

连接器，顾名思义，它的作用就是负责跟客户端建立连接、获取权限、维持和管理连接。
~~~python
"""mysql 连接命令"""
mysql -h$ip -P$port -u$user -p$password
~~~
连接命令是客户端工具，建立完成TCP的三次握手后，就会开始认证用户身份，user、password，如果验证失败就会报`Access denied for user`的错误，如果验证通过连接器会查询该用户拥有的权限。


![connections](http://www.c-blogs.cn/img/mysql-connections.png)
~~~mysql
show variables like '%connections%';
~~~
    extra_max_connections：额外最大连接数
    max_connections：MySQL的最大连接数限制
    max_user_connections：是单个用户的最大连接数，这里未指明是哪个用户，是任意一个用户

> **查询缓存(Cache、Buffer)**

连接建立好后，就可以执行`select`语句了，执行逻辑就会来到第二步：查询缓存。如果能从缓存中找到key，那么这个value就会被直接返回给客户端。如果语句不存在，就会执行并语句，执行结果会存入查询缓存中并把结果返回。

![CahceBuffer](http://www.c-blogs.cn/img/mysql-cache.png)
    全局和引擎特定的缓存和缓冲区
    
> **分析器(Parser)**

当语句没有命中查询缓存，就要开始真正执行语句了。分析器先会做"词法分析"，例子：`select * from mysql.user \G` ，解析字符串分别是什么，代表什么。做完识别后，就要做"语法分析"，就会根据语法规则，判断是否满足MySQL语法。如果不对，就会报`You have an error in your SQL syntax`的错误。

> **优化器(Optimizer)**

经过了分析器后，Mysql就知道你要做什么，在返回数据之前，还要经过优化器的处理。通过`optimizer_switch`控制优化行为。

> **执行器**

经过种种'考验'后，终于进入执行器阶段，但在执行的时候，要判断该用户是否对查询的表、查询的字段等是否有权限，查询也会在优化器之前调用precheck验证权限。如果有，执行器就会根据表的引擎定义，去使用引擎提供的接口，至此，这个语句就执行完成了。

> **引擎(engine)**

![engine](http://www.c-blogs.cn/img/mysql-engine.png)

![engine](http://www.c-blogs.cn/img/mysql-engines.png)
· MyISAM：默认的MySQL插件式存储引擎，它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。注意，通过更改STORAGE_ENGINE配置变量，能够方便地更改MySQL服务器的默认存储引擎。

· InnoDB：用于事务处理应用程序，具有众多特性，包括ACID事务支持。(提供行级锁)

· BDB：可替代InnoDB的事务引擎，支持COMMIT、ROLLBACK和其他事务特性。

· Memory：将所有数据保存在RAM中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。

· Merge：允许MySQL DBA或开发人员将一系列等同的MyISAM表以逻辑方式组合在一起，并作为1个对象引用它们。对于诸如数据仓储等VLDB环境十分适合。

· Archive：为大量很少引用的历史、归档、或安全审计信息的存储和检索提供了完美的解决方案。

· Federated：能够将多个分离的MySQL服务器链接起来，从多个物理服务器创建一个逻辑数据库。十分适合于分布式环境或数据集市环境。

· Cluster/NDB：MySQL的簇式数据库引擎，尤其适合于具有高性能查找要求的应用程序，这类查找需求还要求具有最高的正常工作时间和可用性。

· Other：其他存储引擎包括CSV（引用由逗号隔开的用作数据库表的文件），Blackhole（用于临时禁止对数据库的应用程序输入），以及Example引擎（可为快速创建定制的插件式存储引擎提供帮助）。

## 数据设计

#### ER模型

> 在做项目中，需求分析是极为重要的一个环节，而作为整个项目的核心`数据`更是重中之重。

![ER](http://www.c-blogs.cn/img/ER.png)

**E-R**模型(Entity-Relationship),也有人称为E-R方法。它提供不受任何**DBMS**(database manage system)约束的面向用户的表达方式，是数据建模工具，是表示概念模型的一种方式。

> 联系可分为3种类型：

- **一对一关系**

例如：一个公司有一个项目经理，而那些项目经理只在一个公司任职，则公司与项目经理的关系是一对一。

- **一对多关系**

例如：教师与课程之间存在一对多的联系“教”，即每位教师可以教多门课程，但是每门课程只能由一位教师来教。

- **多对多关系**

例如：学生与课程间的联系(“学”)是多对多的，即一个学生可以学多门课程，而每门课程可以有多个学生来学。

#### 范式与反范式

> 范式(Normal Form)：范式是关系数据库理论的基础，也是我们再设计数据库结构过程中所要遵循的规则和指导方法，共有8种范式，依次是：1NF，2NF，3NF，BCNF，4NF，5NF，DKNF，6NF。通常所用到的只是三个范式，即：第一范式（1NF），第二范式（2NF），第三范式（3NF）。

- 第一范式(1NF)

强调的是列的**原子性**，即列不能够再分成其他的列。

|学号|姓名|手机号|
|----|----|------|
|1|廖|18888888888|

- 第二范式(2NF)

再第一范式的基础上，实体属性完全依赖于主键

|学号|姓名|课程号|授课老师|
|----|----|------|--------|
|1|廖|1|某老师|

可分解为两个表，达到完全依赖

|学号|姓名|
|----|----|
|1|廖|

|学号|课程号|授课老师|
|----|------|--------|
|1|1|某老师|

- 第三范式(3NF)

在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）

|学号|系名|系主任|
|----|----|------|
|1|计算机|某主任|

~~~python
学号 --> 系名 --> 系主任
学号 --> 系主任
ps:为传递依赖
~~~

同样可以分解为两张表：

|学号|系名|
|----|----|
|1|计算机|

|系名|系主任|
|----|------|
|计算机|某主任|

- 反范式

没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，减少了查询时的关联，提高查询效率，因为在数据库的操作中查询的比例要远远大于DML的比例。但是反范式化一定要适度，并且在原本已满足三范式的基础上再做调整的。

## 数据库优化

- SQL查询优化

    - 1.避免全表扫描，应考虑在 where 及 order by 涉及的列上建立索引
    - 2.查询时使用select明确指明所要查询的字段，避免使用select *的操作
    - 3.SQL语句尽量大写，如：
    
    ~~~
    SELECT name FROM t WHERE id=1
    ~~~
    
    - 4.尽量避免在 where 子句中使用!=或<>操作符， MySQL只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE
    
    ~~~
    SELECT id FROM t WHERE name LIKE ‘abc%’
    ~~~
    
    - 5.遵循最左原则，在where子句中写查询条件时把索引字段放在前面
    
    ~~~
    mobile为索引字段，name为非索引字段
    推荐
    SELECT ... FROM t WHERE mobile='13911111111' AND name='python'
    不推荐
    SELECT ... FROM t WHERE name='python' AND mobile='13911111111' 
    
    建立了复合索引 key(a, b, c)
    推荐
    SELECT ... FROM t WHERE a=... AND b=... AND c= ...
    SELECT ... FROM t WHERE a=... AND b=...
    SELECT ... FROM t WHERE a=...
    不推荐 (字段出现顺序不符合索引建立的顺序)
    SELECT ... FROM t WHERE b=... AND c=...
    SELECT ... FROM t WHERE b=... AND a=... AND c=...
    ...
    ~~~
    
    - 6.能使用关联查询解决的尽量不要使用子查询
    
    ~~~
    子查询
    SELECT article_id, title FROM t_article WHERE user_id IN (SELECT user_id FROM t_user  WHERE user_name IN ('itcast', 'itheima', 'python'))
    
    关联查询(推荐)
    SELECT b.article_id, b.title From t_user AS a INNER JOIN t_article AS b ON a.user_id=b.user_id WHERE a.user_name IN ('itcast', 'itheima', 'python');
    ~~~
    
    - 7.不需要获取全表数据的时候，不要查询全表数据，使用LIMIT来限制数据

> - 在进行表设计时，可适度增加冗余字段(反范式设计)，减少JOIN操作； <br> 
> - 多字段表可以进行垂直分表优化，多数据表可以进行水平分表优化； <br> 
> - 选择恰当的数据类型，如整型的选择； <br> 
> - 对于强调快速读取的操作，可以考虑使用MyISAM数据库引擎； <br> 
> - 对较频繁的作为查询条件的字段创建索引；唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件；更新非常频繁的字段不适合创建索引； <br> 
> - 编写SQL时使用上面的方式对SQL语句进行优化； <br> 
> - 使用慢查询工具找出效率低下的SQL语句进行优化； <br> 
> - 构建缓存，减少数据库磁盘操作； <br> 
> - 可以考虑结合使用内在型数据库，如Redis，进行混合存储。

**注：原创文章，转载请注明出处**
