---
layout:     post
title:      Mysql(三)
subtitle:   Mysql 拓展
date:       2019-06-19
author:     Mr.C
header-img: img/mysql-3.jpg
catalog: true
tags:
    - Mysql
    - Database

---

## Mysql 事务(InnoDB)

> Mysql的默认引擎是 `InnoDB` ,是支持事务的,在前Mysql(一)博客中有介绍过。我们在建表时可以指定所需要的引擎。
>> 常用的引擎有两种： <br>
InnoDB：该存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。 <br> 
MyISAM：不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表

```mysql
CREATE TABLE `goods` (
	  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
	  `name` varchar(150) NOT NULL
	) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8
```


* 事务概念：是指作为一个基本单元的一系列sql语句，要么完全执行，要么完全不执行。
* 作用：要么全部执行成功，要么全部执行失败。
* 事务的特征 ACID：
  * `原子性(A)`：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。  

  * `一致性(C)`：事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。某些维护一致性的责任由应用程序开发人员承担，他们必须确保应用程序已强制所有已知的完整性约束。例如，当开发用于转帐的应用程序时，应避免在转帐过程中任意移动小数点。
  * `隔离性(I)`：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。当事务可序列化时将获得最高的隔离级别。在此级别上，从一组可并行执行的事务获得的结果与通过连续运行每个事务所获得的结果相同。由于高度隔离会限制可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量。 
  * `持久性(D)`：事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。


  * 开启事务

    ```mysql
    begin
    or
    start transaction;
    ```
  * 确认修改

    ```mysql
    commit
    ```

  * 回滚

    ```mysql
    rollback
    ```

## 四种隔离级别

- `Read Uncommitted`（读取未提交内容）

> 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

- `Read Committed`（读取提交内容）

> 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

- `Repeatable Read`（可重读）

> 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

- `Serializable`（可串行化） 

> 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：

> `脏读(Drity Read)`：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。

> `不可重复读(Non-repeatable read)`:在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

> `幻读(Phantom Read)`:在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：

|隔离级别|脏读|不可重复读|幻读|
|--------|----|----------|----|
|Read Uncommitted（读取未提交内容）|√|√|√|
|Read Committed（读取提交内容）|×|√|√|
|Repeatable Read（可重读）|×|×|√|
|Serializable（可串行化）|×|×|×|

## 乐观锁、悲观锁

- *悲观锁：*

> 悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）

~~~python
"""当查询某条记录时，即让数据库为该记录加锁，锁住记录后别人无法操作，使用类似如下语法:"""

select stock from tb_sku where id=1 for update;

SKU.objects.select_for_update().get(id=1)
~~~

- *乐观锁：*

> 乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做（一般是回滚事务）。

~~~python
"""乐观锁并不是真实存在的锁，而是在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新。类似如下操作:"""

update tb_sku set stock=2 where id=1 and stock=7;

SKU.objects.filter(id=1, stock=7).update(stock=2)
~~~

## 表锁、行锁

> 表级锁(table-level locking)：MyISAM和MEMORY存储引擎 <br> 
行级锁(row-level locking) ：InnoDB存储引擎 <br> 
页面锁(page-level-locking)：BDB存储引擎

表级锁：开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高,并发度最低。

行级锁：开销大，加锁慢;会出现死锁;锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

页面锁：开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般。

 

## 共享锁、排它锁

> InnoDB引擎的锁机制：InnoDB支持事务，支持行锁和表锁用的比较多，Myisam不支持事务，只支持表锁。

- 共享锁（S）：

允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。

- 排他锁（X)：

允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。

- 意向排他锁（IX）：

事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

 

**注：原创文章，转载请注明出处**
