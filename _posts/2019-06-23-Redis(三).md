---
layout:     post
title:      Redis 策略
subtitle:   Redis 缓存策略、缓存问题
date:       2019-06-23
author:     Mr.C
header-img: img/redis_wallpaper.jpg
catalog: true
tags:
    - Redis
    - Database

---

> 虽然在前面介绍过`Redis`数据库是支持持久化存储的，但`Redis`定位于一个内存数据库，正是由于内存的快速访问特性，才使得`Redis`能够有如此高的性能，下面讲讲`Redis`在缓存架构中的重要作用和`Redis`的策略。

![Redis](http://www.c-blogs.cn/img/redis_cache.png)

> 对于高并发构架，毫无疑问缓存是最重要的一环，CPU的速度远远高于磁盘 IO的速度，所以要想提高响应速度，必须减少磁盘IO的操作，使用缓存可以有效的避免这种情况。

## Redis 缓存有效期与淘汰策略

#### Redis 过期策略

![Redis](http://www.c-blogs.cn/img/redis_1.png)

> 由于Redis是内存型数据库，数据会占据CPU的内存，Rdis的贪婪模式会将内存占用完，所以需要将Redis贪婪模式设置为固定大小和数据有效时长。
>> 设置有效期的作用： <br> 
1.节省空间 <br> 
2.做到数据弱一致性，有效期失效后，可以保证数据的一致性 <br> 
 <br> 
Redis过期策略： <br> 
1.定时过期 <br> 
2.惰性过期 <br> 
3.定期过期 <br> 

- **定时过期**

~~~redis
setex key seconds value
~~~

每个设置过期时间的key都需要创建一个定时器，该策略会占用大量的CPU资源，因为CPU会创建一个进程或子进程时时刻刻的监视，从而影响缓存的响应时间和吞吐量。

- **惰性过期**

当访问一个key时，才会判断key是否过期，该策略可以最大化节省CPU资源，极端情况下可能会出现大量过期key没有再次访问时，会占用大量内存。

- **定期过期**

每隔一段时间(默认100ms检查)，会扫扫描数据库中一定数量的key，并清除过期key。

> Redis中使用惰性过期和定期过期这两种过期策略。如果定期删除没有删除key，惰性删除也没有生效，这样Redis的内存会越来月高，那么就应该采用淘汰机制。

#### 缓存淘汰(eviction)

![Redis](http://www.c-blogs.cn/img/redis_2.png)

>  Redis内存不足的情况下，如何写入新数据、如何申请新的存储空间、如何删除旧数据，这时就需要缓存淘汰策略。
>> `LRU`(Least Recently Used —— 时间的角度):最近最少使用，判断最近被使用的时间，目前最远的数据优先被淘汰 <br> 
`LFU`(Least Frequently Used —— 频率的角度):最不经常使用，在一段时间内，数据被使用次数最少的，优先被淘汰

- noeviction(`Redis`默认)：当内存不足以容纳新写入数据时，新写入操作会报错。
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

## 缓存问题

> 缓存只是为了缓解数据库压力而添加的一层保护层，如果失去缓存存在的意义，瞬间所有的请求压力会落在数据库上，会导致数据库连接异常等，从而造成不可估量的损失。

#### 缓存穿透

>  缓存穿透是指查询一个一定不存在的数据，缓存未命中，从而需要到储存层进行查询，如果在流量大时或者有人利用不存在的key时，频繁访问或恶意攻击，可能会造成数据库挂掉。

解决办法：

![redis](http://www.c-blogs.cn/img/redis_bulong.png)

1.布隆过滤器:制定规则过滤一些不存在的数据，小数据使用BitMap,大数据可以使用布隆过滤器

![redis](http://www.c-blogs.cn/img/redis_null.png)

2.将不存在的key使用NULL，采用这种手段会增加我们缓存的维护成本，在当我们需要插入缓存的时候删除这个空缓存


#### 缓存雪崩

![redis](http://www.c-blogs.cn/img/redis_3.jpg)

> 缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到数据库，导致瞬间压力过重雪崩。

解决办法：

1.给缓存加上一定区间内的随机生效时间，不同的key设置不同的失效时间，避免同一时间集体失效。比如以前是设置10分钟的超时时间，那每个Key都可以随机8-13分钟过期，尽量让不同Key的过期时间不同。

2.采用多级缓存，不同级别缓存设置的超时时间不同，及时某个级别缓存都过期，也有其他级别缓存兜底。

3.利用加锁或者队列方式避免过多请求同时对服务器进行读写操作。
