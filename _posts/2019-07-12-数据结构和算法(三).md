---
layout:     post
title:      数据结构和算法(三)
subtitle:   数据结构的实现
date:       2019-07-12
author:     Mr.C
header-img: img/algorithm2.jpg
catalog: true
tags:
    - algorithm
    - data structure

---

## 栈

>后进者先出，先进者后出，这就是典型的"栈"的结构。栈(stack)，有些地方也称为堆栈，是一种容器，由于栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作
>> 栈是一种操作受限的线性表，只允许在一端插入或删除数据

栈中的插入操作，也叫进栈或压栈

![进栈](http://www.c-blogs.cn/img/进栈.png)

栈中的删除操作，也叫出栈或弹栈

![出栈](http://www.c-blogs.cn/img/进栈.png)

~~~python
"""
Stack() 创建一个新的空栈
push(item) 添加一个新的元素item到栈顶
pop() 弹出栈顶元素
peek() 返回栈顶元素
is_empty() 判断栈是否为空
size() 返回栈的元素个数
"""


class Stack(object):
    """栈"""
    def __init__(self):
         self.items = []

    def is_empty(self):
        """判断是否为空"""
        return self.items == []

    def push(self, item):
        """加入元素"""
        self.items.append(item)

    def pop(self):
        """弹出元素"""
        return self.items.pop()

    def peek(self):
        """返回栈顶元素"""
        return self.items[len(self.items)-1]

    def size(self):
        """返回栈的大小"""
        return len(self.items)

if __name__ == "__main__":
    stack = Stack()
    stack.push("hello")
    stack.push("true")
    print(stack.pop())
    print(stack.size())
    print(stack.peek())


运行结果==>
true
1
hello
~~~

**执行过程:**

![运行结果](http://www.c-blogs.cn/img/stack演示.gif)


## 队列

>队列和栈恰恰相反，是后进者后出，先进者先出，这种数据结构就叫"队列"。队列是一种先进先出的（First In First Out）的线性表，简称FIFO。允许插入的一端为队尾，允许删除的一端为队头。队列不允许在中间部位进行操作
>>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表


~~~python
"""
Queue() 创建一个空的队列
enqueue(item) 往队列中添加一个item元素
dequeue() 从队列头部删除一个元素
is_empty() 判断一个队列是否为空
size() 返回队列的大小
"""


class Queue(object):
    """队列"""

    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, item):
        """进队列"""
        self.items.insert(0, item)

    def dequeue(self):
        """出队列"""
        return self.items.pop()

    def size(self):
        """返回大小"""
        return len(self.items)


if __name__ == "__main__":
    q = Queue()
    q.enqueue("hello")
    print(q.size())
    print(q.dequeue())


运行结果==>
1
hello
~~~

## 双端队列

> 双端队列（deque，全名double-ended queue），是一种具有队列和栈的性质的数据结构
>> 双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队

~~~python
"""
Deque() 创建一个空的双端队列
add_front(item) 从队头加入一个item元素
add_rear(item) 从队尾加入一个item元素
remove_front() 从队头删除一个item元素
remove_rear() 从队尾删除一个item元素
is_empty() 判断双端队列是否为空
size() 返回队列的大小
"""


class Deque(object):
    """双端队列"""
    def __init__(self):
        self.items = []

    def is_empty(self):
        """判断队列是否为空"""
        return self.items == []

    def add_front(self, item):
        """在队头添加元素"""
        self.items.insert(0,item)

    def add_rear(self, item):
        """在队尾添加元素"""
        self.items.append(item)

    def remove_front(self):
        """从队头删除元素"""
        return self.items.pop(0)

    def remove_rear(self):
        """从队尾删除元素"""
        return self.items.pop()

    def size(self):
        """返回队列大小"""
        return len(self.items)


if __name__ == "__main__":
    deque = Deque()
    deque.add_front(1)
    deque.add_front(2)
    deque.add_rear(3)
    deque.add_rear(4)
    print(deque.size())
    print(deque.remove_front())
    print(deque.remove_rear())


运行结果==>
4
2
4
~~~


**注：原创文章，转载请注明出处**
